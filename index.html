<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>The Forge - Neural Synthesis Engine | Neurofoundry</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body { 
      background: transparent; /* moved solid background to .page-background so furnace can sit above it */
      color: #e6e9ee; 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      line-height: 1.6;
    }
    
    /* Header Styles */
    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 2000;
      background: rgba(11, 12, 14, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 2px solid #e0473c;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      height: 64px;
    }
    .nav {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 100%;
      max-width: 1600px;
      margin: 0 auto;
      padding: 0 18px;
      width: 100%;
    }
    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      font-size: 16px;
      letter-spacing: 0.5px;
      text-decoration: none;
      color: #e6e9ee;
    }
    .brand-icon {
      width: 36px;
      height: 36px;
      background: linear-gradient(135deg, #ff7b6e 0%, #e0473c 100%);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
      font-size: 18px;
      color: white;
      box-shadow: 0 4px 12px rgba(224, 71, 60, 0.3);
    }
    .links {
      display: flex;
      align-items: center;
      gap: 20px;
    }
    .navlink {
      color: #ccc;
      font-size: 14px;
      font-weight: 500;
      text-decoration: none;
      transition: color 0.2s;
    }
    .navlink:hover { color: #e0473c; }
    .nav-item { position: relative; }
    .dropdown-toggle {
      background: none;
      border: none;
      padding: 0;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      color: #ccc;
      font: 500 14px/1 Inter, sans-serif;
      transition: color 0.2s;
    }
    .dropdown-toggle:hover,
    .dropdown-toggle:focus-visible {
      color: #e0473c;
      outline: none;
    }
    .dropdown-caret {
      font-size: 11px;
      opacity: 0.7;
    }
    .dropdown-menu {
      position: absolute;
      top: calc(100% + 6px);
      left: 0;
      min-width: 200px;
      background: rgba(15, 17, 19, 0.96);
      border: 1px solid rgba(224, 71, 60, 0.25);
      border-radius: 12px;
      padding: 10px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
      opacity: 0;
      transform: translateY(6px);
      pointer-events: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 50;
    }
    .dropdown::after {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: 100%;
      height: 10px;
    }
    .dropdown-menu a {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 8px;
      color: #c9d0d8;
      text-decoration: none;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.2s, color 0.2s;
      white-space: nowrap;
    }
    .dropdown-menu a:hover {
      background: rgba(224, 71, 60, 0.18);
      color: #fff;
    }
    .dropdown:hover .dropdown-menu,
    .dropdown:focus-within .dropdown-menu {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 8px 18px;
      border-radius: 8px;
      font: 600 13px/1 Inter, sans-serif;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.2s ease;
      border: 2px solid transparent;
    }
    .btn.primary {
      background: linear-gradient(180deg, #ff7b6e 0%, #e9584d 48%, #d23d33 100%);
      border-color: #a2362f;
      color: #fff;
      box-shadow: 0 4px 12px rgba(224, 71, 60, 0.3);
    }
    .btn.primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(224, 71, 60, 0.4);
    }
    
    /* Main Container */
    .forge-container {
      width: 100%;
      height: calc(100vh - 64px);
      margin-top: 64px;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Background with furnace images layered */
    /* Furnace background split into front (furnace.png) and back (furnacebg.png)
       so the media viewer can layer between them */
    .furnace-front {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 450; /* sit just beneath the media viewer */
      background-image: url('../../furnace.png');
      background-size: 60% auto;
      background-position: center center;
      background-repeat: no-repeat;
      background-attachment: fixed;
      opacity: 1;
      transition: opacity 0.3s ease;
      -webkit-mask-image: linear-gradient(90deg, transparent 0%, transparent 15%, #000 35%, #000 65%, transparent 85%, transparent 100%);
      mask-image: linear-gradient(90deg, transparent 0%, transparent 15%, #000 35%, #000 65%, transparent 85%, transparent 100%);
    }
    .furnace-front.is-hidden {
      opacity: 0;
      pointer-events: none;
    }
    .furnace-back {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0; /* place furnace background at the very bottom */
      background-image: url('../../furnacebg.png');
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      background-attachment: fixed;
      animation: kenburns-loop 15s ease-in-out infinite;
      -webkit-mask-image: linear-gradient(90deg, transparent 0%, transparent 15%, #000 35%, #000 65%, transparent 85%, transparent 100%);
      mask-image: linear-gradient(90deg, transparent 0%, transparent 15%, #000 35%, #000 65%, transparent 85%, transparent 100%);
    }

    /* Page solid background moved here so furnace images can sit above it */
    .page-background {
      position: fixed;
      inset: 0;
      z-index: -1;
      background: #0a0a0a;
    }
    
    /* Overlay for darker furnace area */
    .furnace-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 3;
      background: 
        radial-gradient(circle at 50% 40%, rgba(255, 100, 50, 0.1) 0%, rgba(0, 0, 0, 0.3) 100%),
        linear-gradient(180deg, rgba(0, 0, 0, 0.1) 0%, rgba(0, 0, 0, 0.5) 100%);
      pointer-events: none;
    }
    
    /* Ember particles */
    .ember-container {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 800; /* sequence position 4 (effects) */
      pointer-events: none;
    }
    
    .ember {
      position: absolute;
      width: 2px;
      height: 2px;
      background: #ff7b6e;
      border-radius: 50%;
      animation: rise 4s infinite;
      opacity: 0;
      box-shadow: 0 0 6px #ff7b6e;
    }
    
    @keyframes rise {
      0% { 
        opacity: 0;
        transform: translateY(0) translateX(0);
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 0.5;
      }
      100% { 
        opacity: 0;
        transform: translateY(-300px) translateX(var(--drift, 0));
      }
    }
    
    .ember:nth-child(1) { left: 20%; top: 50%; animation-delay: 0s; animation-duration: 1.25s; --drift: -37px; }
    .ember:nth-child(2) { left: 30%; top: 55%; animation-delay: 0.2s; animation-duration: 1.375s; --drift: 25px; }
    .ember:nth-child(3) { left: 40%; top: 50%; animation-delay: 0.4s; animation-duration: 1.5s; --drift: -18px; }
    .ember:nth-child(4) { left: 50%; top: 60%; animation-delay: 0.6s; animation-duration: 1.3s; --drift: 31px; }
    .ember:nth-child(5) { left: 60%; top: 50%; animation-delay: 0.8s; animation-duration: 1.45s; --drift: -25px; }
    .ember:nth-child(6) { left: 70%; top: 55%; animation-delay: 1s; animation-duration: 1.375s; --drift: 18px; }
    .ember:nth-child(7) { left: 25%; top: 60%; animation-delay: 1.2s; animation-duration: 1.325s; --drift: -31px; }
    .ember:nth-child(8) { left: 75%; top: 55%; animation-delay: 1.4s; animation-duration: 1.425s; --drift: 12px; }
    
    /* Main workspace - overlays panels on furnace */
    .workspace {
      position: relative;
      z-index: 1100; /* UI controls should be top (sequence position 1) */
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    
    /* Panels overlay container */
    .panels-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1100; /* UI controls on top */
      padding: 30px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      pointer-events: none;
    }
    
    /* Top row - title and controls */
    .furnace-header {
      display: flex;
      justify-content: space-between;
      width: 100%;
      margin-bottom: 40px;
      pointer-events: all;
    }
    
    .header-label {
      font-size: 11px;
      font-weight: 600;
      color: #c9a877;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      padding: 6px 12px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 4px;
      backdrop-filter: blur(10px);
    }
    
    /* Side panels row */
    .panels-row {
      position: absolute;
      top: 100px;
      left: 0;
      right: 0;
      width: 100%;
      height: calc(100% - 130px);
      padding: 0 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
    }
    
    .panel {
      /* Make panels solid and non-blended so they stand out above the furnace artwork */
      position: relative;
      background: #0b0b0b; /* fully opaque */
      border: 1px solid rgba(224, 71, 60, 0.9);
      border-radius: 10px;
      padding: 16px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.85), inset 0 1px 0 rgba(224, 71, 60, 0.15);
      /* remove backdrop blur so panels look solid */
      backdrop-filter: none;
      pointer-events: all;
      max-height: 65%;
      overflow-y: auto;
      width: 220px;
      flex-shrink: 0;
    }
    .panel.right-panel {
      max-height: 89%;
    }
    .synth-loading {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(6, 5, 4, 0.78);
      border-radius: 10px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 2;
    }
    .synth-loading.active {
      opacity: 1;
      pointer-events: all;
    }
    .synth-loading-card {
      padding: 16px 20px;
      border-radius: 10px;
      background: rgba(12, 9, 9, 0.9);
      border: 1px solid rgba(224, 71, 60, 0.4);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
      text-align: center;
      min-width: 180px;
    }
    .synth-loading-text {
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: #ffb3ab;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.9);
      margin-bottom: 10px;
    }
    .synth-loading-bar {
      height: 6px;
      border-radius: 999px;
      background: rgba(224, 71, 60, 0.15);
      overflow: hidden;
    }
    .synth-loading-fill {
      display: block;
      height: 100%;
      width: 45%;
      background: linear-gradient(90deg, rgba(178, 28, 28, 0.4), rgba(224, 71, 60, 0.9));
      animation: synth-loading 1.1s ease-in-out infinite;
    }
    @keyframes synth-loading {
      0% { transform: translateX(-120%); }
      100% { transform: translateX(220%); }
    }
    
    .panel::-webkit-scrollbar {
      width: 4px;
    }
    .panel::-webkit-scrollbar-track {
      background: rgba(224, 71, 60, 0.1);
      border-radius: 2px;
    }
    .panel::-webkit-scrollbar-thumb {
      background: rgba(224, 71, 60, 0.4);
      border-radius: 2px;
    }
    .panel::-webkit-scrollbar-thumb:hover {
      background: rgba(224, 71, 60, 0.6);
    }
    
    .panel-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(224, 71, 60, 0.2);
    }
    
    .step-number {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, #e0473c, #ff7b6e);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
      font-size: 13px;
      flex-shrink: 0;
      box-shadow: 0 4px 12px rgba(224, 71, 60, 0.4);
    }
    
    .panel-title {
      font-size: 13px;
      font-weight: 700;
      color: #e6e9ee;
    }
    
    .panel-description {
      font-size: 10px;
      color: #9aa3ad;
      margin-bottom: 12px;
      line-height: 1.4;
    }
    
    /* Upload Zone */
    .upload-zone {
      border: 2px dashed rgba(224, 71, 60, 0.4);
      border-radius: 6px;
      padding: 25px 12px;
      text-align: center;
      background: rgba(224, 71, 60, 0.05);
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      min-height: 92px;
    }
    .upload-zone.has-origin {
      padding: 0;
      background: rgba(224, 71, 60, 0.08);
    }
    .origin-preview {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      pointer-events: none;
    }
    .origin-clear {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 1px solid rgba(224, 71, 60, 0.7);
      background: rgba(12, 10, 10, 0.8);
      color: #ffb3ab;
      font-size: 14px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 2;
      box-shadow: 0 0 10px rgba(224, 71, 60, 0.4);
    }
    .origin-clear:hover {
      background: rgba(224, 71, 60, 0.25);
      color: #fff;
    }
    
    .upload-zone:hover {
      border-color: #e0473c;
      background: rgba(224, 71, 60, 0.1);
    }
    
    .upload-icon {
      width: 36px;
      height: 36px;
      margin: 0 auto 6px;
      background: linear-gradient(135deg, rgba(224, 71, 60, 0.2), rgba(224, 71, 60, 0.1));
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }
    
    /* Fusion Grid */
    .fusion-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      margin-bottom: 10px;
    }
    
    .fusion-item {
      background: rgba(224, 71, 60, 0.05);
      border: 1px dashed rgba(224, 71, 60, 0.3);
      border-radius: 6px;
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      overflow: hidden;
    }
    .fusion-item.is-locked {
      cursor: default;
      pointer-events: none;
      opacity: 0.6;
    }
    
    .fusion-item:hover {
      background: rgba(224, 71, 60, 0.15);
      border-color: #e0473c;
    }
    
    .fusion-icon {
      font-size: 16px;
      margin-bottom: 3px;
      opacity: 0.8;
    }
    
    .fusion-label {
      font-size: 8px;
      font-weight: 600;
      color: #c9d0d8;
      text-transform: uppercase;
      letter-spacing: 0.2px;
    }
    .fusion-hint {
      font-size: 7px;
      color: #7b8088;
      margin-top: 4px;
      text-transform: uppercase;
      letter-spacing: 0.2px;
    }
    .fusion-item input {
      display: none;
    }
    .fusion-item.has-image {
      border-color: #e0473c;
      background-size: cover;
      background-position: center;
    }
    .fusion-check {
      position: absolute;
      top: 6px;
      right: 6px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: rgba(46, 213, 115, 0.9);
      box-shadow: 0 0 8px rgba(46, 213, 115, 0.5);
      opacity: 0;
      transform: scale(0.8);
      transition: opacity 0.2s ease, transform 0.2s ease;
    }
    .fusion-check::after {
      content: '';
      position: absolute;
      left: 4px;
      top: 6px;
      width: 6px;
      height: 3px;
      border-left: 2px solid #0b0b0b;
      border-bottom: 2px solid #0b0b0b;
      transform: rotate(-45deg);
    }
    .fusion-item.has-image .fusion-check {
      opacity: 1;
      transform: scale(1);
    }
    .fusion-item.has-image .fusion-label,
    .fusion-item.has-image .fusion-hint {
      background: rgba(10, 10, 10, 0.7);
      padding: 2px 4px;
      border-radius: 3px;
    }
    .fusion-grid.disabled {
      opacity: 0.35;
      pointer-events: none;
    }
    .fusion-clear {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 1px solid rgba(224, 71, 60, 0.7);
      background: rgba(12, 10, 10, 0.8);
      color: #ffb3ab;
      font-size: 14px;
      font-weight: 700;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 2;
      box-shadow: 0 0 10px rgba(224, 71, 60, 0.4);
    }
    .fusion-clear.visible {
      display: flex;
    }
    .fusion-clear:hover {
      background: rgba(224, 71, 60, 0.25);
      color: #fff;
    }
    .fusion-status {
      margin-top: 8px;
      font-size: 9px;
      color: #9aa3ad;
      min-height: 12px;
    }
    .fusion-progress {
      margin-top: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(224, 71, 60, 0.12);
      border: 1px solid rgba(224, 71, 60, 0.3);
      overflow: hidden;
      box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.6);
    }
    .fusion-progress-fill {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(178, 28, 28, 0.6), rgba(224, 71, 60, 0.9));
      transition: width 0.3s ease;
    }
    .panel-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }
    
    .furnace-toggle-btn {
      margin-top: 8px;
      padding: 4px 8px;
      font-size: 9px;
      background: rgba(224, 71, 60, 0.1);
      border: 1px solid rgba(224, 71, 60, 0.3);
      border-radius: 3px;
      color: rgba(224, 71, 60, 0.6);
      cursor: pointer;
      transition: all 0.2s;
    }
    .furnace-toggle-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      box-shadow: none;
    }
    
    .furnace-toggle-btn:hover {
      background: rgba(224, 71, 60, 0.2);
      color: rgba(224, 71, 60, 0.8);
    }
    
    /* Buttons */
    .generate-btn, .ai-generate-btn, .render-btn {
      width: 100%;
      border: none;
      border-radius: 6px;
      color: white;
      font-size: 10px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }
    
    .generate-btn {
      padding: 9px;
      background: linear-gradient(135deg, rgba(224, 71, 60, 0.8), rgba(224, 71, 60, 0.6));
      margin-top: 10px;
      box-shadow: 0 4px 12px rgba(224, 71, 60, 0.3);
    }
    .generate-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }
    .ai-generate-btn:disabled,
    .render-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
      pointer-events: none;
    }
    
    .generate-btn:hover {
      background: linear-gradient(135deg, #e0473c, #ff7b6e);
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(224, 71, 60, 0.5);
    }
    
    /* Input fields */
    .input-group {
      margin-bottom: 10px;
    }
    
    .input-label {
      font-size: 8px;
      font-weight: 600;
      color: #c9d0d8;
      margin-bottom: 3px;
      display: flex;
      align-items: center;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 0.2px;
    }
    .field-check {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid rgba(224, 71, 60, 0.35);
      background: rgba(0, 0, 0, 0.45);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      opacity: 0.6;
      box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.5);
    }
    .field-check::after {
      content: '';
      width: 6px;
      height: 3px;
      border-left: 2px solid #0b0b0b;
      border-bottom: 2px solid #0b0b0b;
      transform: rotate(-45deg);
      opacity: 0;
    }
    .field-check.active {
      background: rgba(46, 213, 115, 0.95);
      border-color: rgba(46, 213, 115, 0.95);
      opacity: 1;
      box-shadow: 0 0 8px rgba(46, 213, 115, 0.6);
    }
    .field-check.active::after {
      opacity: 1;
    }
    .right-panel-stack {
      width: 220px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      pointer-events: all;
    }
    
    .input-field, .input-select {
      width: 100%;
      padding: 6px 8px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(224, 71, 60, 0.3);
      border-radius: 4px;
      color: #e6e9ee;
      font-size: 10px;
      font-family: inherit;
      transition: all 0.2s;
    }
    
    .input-field:focus, .input-select:focus {
      outline: none;
      border-color: #e0473c;
      background: rgba(0, 0, 0, 0.7);
      box-shadow: 0 0 0 3px rgba(224, 71, 60, 0.1);
    }
    
    .input-field {
      resize: vertical;
      min-height: 35px;
    }
    
    .ai-generate-btn {
      padding: 9px;
      background: linear-gradient(135deg, rgba(224, 71, 60, 0.8), rgba(224, 71, 60, 0.6));
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      margin-top: 10px;
      box-shadow: 0 4px 12px rgba(224, 71, 60, 0.3);
    }
    
    .ai-generate-btn:hover {
      background: linear-gradient(135deg, #e0473c, #ff7b6e);
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(224, 71, 60, 0.5);
    }
    
    .render-btn {
      width: 100%;
      margin-top: 12px;
      background: transparent;
      position: relative;
      padding: 0;
      border: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      align-self: center;
      cursor: pointer;
      transition: transform 0.2s ease, filter 0.2s ease, opacity 0.2s ease;
    }
    .render-btn img {
      width: 190px;
      max-width: 100%;
      height: auto;
      display: block;
      filter: drop-shadow(0 6px 18px rgba(178, 28, 28, 0.4));
      transition: filter 0.2s ease;
    }
    .render-btn.ready img {
      filter:
        drop-shadow(0 0 16px rgba(178, 28, 28, 0.75))
        drop-shadow(0 0 28px rgba(150, 20, 20, 0.65))
        drop-shadow(0 10px 24px rgba(178, 28, 28, 0.6));
    }
    .render-btn.is-disabled {
      opacity: 0.45;
      cursor: not-allowed;
      pointer-events: none;
    }
    .render-btn:hover {
      transform: translateY(-2px);
    }
    
    /* Left panels container */
    .left-panels {
      display: flex;
      flex-direction: column;
      gap: 15px;
      flex-shrink: 0;
    }
    
    /* Media Viewer - sits in furnace opening */
    .media-viewer {
      position: absolute;
      top: 52%;
      left: 50%;
      transform: translate(-50%, calc(-50% - 60px));
      width: 47.5%;
      aspect-ratio: 16 / 9;
      background: #000000;
      border: none;
      border-radius: 2px;
      z-index: 500; /* behind furnace.png frame so video appears inside furnace */
      overflow: hidden;
      box-shadow: 
        inset 0 0 30px rgba(0, 0, 0, 0.9),
        0 0 40px rgba(0, 0, 0, 0.6);
    }
    
    .media-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000000;
      position: relative;
    }
    
    .media-content {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .media-content video,
    .media-content img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    .media-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      color: #666666;
      gap: 12px;
    }
    
    .placeholder-icon {
      font-size: 48px;
      opacity: 0.4;
    }
    
    .placeholder-text {
      font-size: 12px;
      color: #555555;
      text-align: center;
    }
    .media-viewer.processing .media-placeholder {
      opacity: 0.3;
    }
    .holo-screen-container {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .media-viewer.processing .holo-screen-container {
      opacity: 1;
    }
    .media-viewer.degen-active {
      filter: url(#forge-wavy);
    }
    .svg-filters {
      position: absolute;
      width: 0;
      height: 0;
      overflow: hidden;
    }
    .holo-screen {
      position: relative;
      width: 60px;
      height: 80px;
      background: linear-gradient(135deg,
        rgba(255, 200, 0, 0.1),
        rgba(255, 165, 0, 0.2),
        rgba(255, 140, 0, 0.1)
      );
      border: 2px solid rgba(255, 180, 0, 0.6);
      border-radius: 4px;
      box-shadow:
        0 0 20px rgba(255, 165, 0, 0.4),
        0 0 40px rgba(255, 140, 0, 0.3),
        inset 0 0 20px rgba(255, 200, 0, 0.1);
      animation: holo-expand 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) infinite;
      overflow: hidden;
    }
    .holo-screen::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg,
        transparent,
        rgba(255, 180, 0, 0.3),
        transparent
      );
      animation: holo-scan 3s linear infinite;
    }
    .holo-screen::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        0deg,
        rgba(255, 180, 0, 0.1) 0px,
        transparent 2px,
        transparent 4px
      );
      animation: holo-lines 0.1s linear infinite;
    }
    @keyframes holo-expand {
      0% {
        width: 60px;
        height: 80px;
        opacity: 0;
        border-color: rgba(255, 180, 0, 0);
        box-shadow: 0 0 0 rgba(255, 165, 0, 0);
      }
      15% {
        opacity: 1;
        border-color: rgba(255, 180, 0, 0.8);
        box-shadow:
          0 0 30px rgba(255, 165, 0, 0.6),
          0 0 60px rgba(255, 140, 0, 0.4),
          inset 0 0 30px rgba(255, 200, 0, 0.2);
      }
      50% {
        width: 500px;
        height: 320px;
        opacity: 0.85;
        border-color: rgba(255, 180, 0, 0.6);
      }
      85% {
        opacity: 0.75;
        border-color: rgba(255, 180, 0, 0.4);
      }
      100% {
        width: 60px;
        height: 80px;
        opacity: 0;
        border-color: rgba(255, 180, 0, 0);
        box-shadow: 0 0 0 rgba(255, 165, 0, 0);
      }
    }
    @keyframes holo-scan {
      0% { left: -100%; }
      100% { left: 200%; }
    }
    @keyframes holo-lines {
      0% { opacity: 0.1; }
      50% { opacity: 0.25; }
      100% { opacity: 0.1; }
    }

    .forge-popup-overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(7, 6, 4, 0.7);
      backdrop-filter: blur(14px) saturate(1.1);
      -webkit-backdrop-filter: blur(14px) saturate(1.1);
      z-index: 3000;
    }
    .forge-popup-overlay.active {
      display: flex;
    }
    .forge-popup-shell {
      position: absolute;
      width: 80vw;
      height: 80vh;
      max-width: 1200px;
      max-height: 840px;
      opacity: 0;
      transform: scale(0.98);
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 1;
    }
    .forge-popup-window {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(20, 12, 12, 0.92), rgba(10, 8, 8, 0.96));
      border-radius: 8px;
      border: 1px solid rgba(224, 71, 60, 0.45);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
    }
    .forge-popup-holo {
      position: absolute;
      inset: 0;
      border-radius: 8px;
      border: 2px solid rgba(224, 71, 60, 0.6);
      box-shadow:
        0 0 30px rgba(224, 71, 60, 0.35),
        inset 0 0 20px rgba(255, 140, 120, 0.12);
      background: repeating-linear-gradient(
        0deg,
        rgba(224, 71, 60, 0.08) 0px,
        transparent 2px,
        transparent 4px
      );
      opacity: 0.75;
      pointer-events: none;
    }
    .forge-popup-shell.results-started .forge-popup-holo {
      opacity: 0.28;
      border-color: rgba(224, 71, 60, 0.4);
      box-shadow:
        0 0 18px rgba(224, 71, 60, 0.4),
        inset 0 0 14px rgba(255, 140, 120, 0.12);
      background: repeating-linear-gradient(
        90deg,
        rgba(224, 71, 60, 0.12) 0px,
        transparent 8px,
        transparent 18px
      );
      animation: holo-scan 5s linear infinite;
    }
    .forge-popup-content {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 18px;
      padding: 28px 32px 36px;
      text-align: center;
      color: #f4c36b;
      z-index: 2;
    }
    .forge-popup-title {
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #ff8c82;
      text-shadow:
        0 4px 8px rgba(0, 0, 0, 0.98),
        0 0 24px rgba(0, 0, 0, 0.9),
        0 0 40px rgba(0, 0, 0, 0.75),
        0 0 58px rgba(224, 71, 60, 0.4);
      min-height: 28px;
    }
    .forge-popup-shell.complete .forge-popup-title {
      font-size: 36px;
      letter-spacing: 0.12em;
      color: #ffd2c9;
      text-shadow:
        0 6px 12px rgba(0, 0, 0, 0.98),
        0 0 30px rgba(0, 0, 0, 0.95),
        0 0 48px rgba(0, 0, 0, 0.8),
        0 0 70px rgba(224, 71, 60, 0.5);
      transform: translateY(-20px);
    }
    .forge-popup-status {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 18px;
    }
    .forge-popup-message {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: #ffb3ab;
      text-shadow:
        0 4px 8px rgba(0, 0, 0, 0.98),
        0 0 22px rgba(0, 0, 0, 0.9),
        0 0 38px rgba(0, 0, 0, 0.75),
        0 0 54px rgba(224, 71, 60, 0.35);
      min-height: 26px;
    }
    .forge-popup-cogs {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      min-height: 110px;
    }
    .forge-cog {
      width: 90px;
      height: 90px;
      border-radius: 50%;
      background-color: rgba(8, 6, 3, 0.8);
      border: 2px solid rgba(224, 71, 60, 0.35);
      box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.6);
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      opacity: 0.85;
      animation: forge-cog-spin 6s linear infinite;
    }
    #forgeCogLeft {
      background-image: url('../../assets/loading/c2.png');
    }
    #forgeCogCenter {
      background-image: url('../../assets/loading/c3.png');
    }
    #forgeCogRight {
      background-image: url('../../assets/loading/c4.png');
    }
    .forge-cog.cog-mid {
      width: 110px;
      height: 110px;
      animation-duration: 8s;
    }
    .forge-cog.cog-rev {
      animation-direction: reverse;
      animation-duration: 5s;
    }
    .forge-popup-results {
      display: grid;
      width: min(86%, 1100px);
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 18px;
    }
    .forge-popup-thumb {
      background: #050505;
      border: 1px solid rgba(224, 71, 60, 0.35);
      border-radius: 6px;
      aspect-ratio: 16 / 9;
      box-shadow: inset 0 0 18px rgba(0, 0, 0, 0.8);
      overflow: hidden;
    }
    .forge-popup-shell.complete .forge-popup-thumb {
      box-shadow:
        0 0 16px rgba(224, 71, 60, 0.35),
        0 0 28px rgba(178, 28, 28, 0.4),
        inset 0 0 18px rgba(0, 0, 0, 0.8);
      border-color: rgba(224, 71, 60, 0.6);
      animation: forge-thumb-pulse 1.8s ease-in-out infinite;
    }
    @keyframes forge-thumb-pulse {
      0%, 100% {
        box-shadow:
          0 0 14px rgba(224, 71, 60, 0.3),
          0 0 26px rgba(178, 28, 28, 0.35),
          inset 0 0 18px rgba(0, 0, 0, 0.8);
        border-color: rgba(224, 71, 60, 0.5);
      }
      50% {
        box-shadow:
          0 0 22px rgba(224, 71, 60, 0.55),
          0 0 36px rgba(178, 28, 28, 0.55),
          inset 0 0 18px rgba(0, 0, 0, 0.8);
        border-color: rgba(224, 71, 60, 0.8);
      }
    }
    .forge-popup-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
    }
    .forge-popup-thumb img:not([src=""]) {
      display: block;
    }
    .forge-popup-shell.complete .forge-popup-status {
      display: none;
    }
    .forge-popup-overlay.ready .forge-popup-shell {
      opacity: 1;
      transform: scale(1);
    }
    .forge-holo-anim {
      position: relative;
      width: 60px;
      height: 80px;
      background: linear-gradient(135deg,
        rgba(255, 140, 120, 0.12),
        rgba(224, 71, 60, 0.2),
        rgba(180, 40, 30, 0.1)
      );
      border: 2px solid rgba(224, 71, 60, 0.7);
      border-radius: 4px;
      box-shadow:
        0 0 20px rgba(224, 71, 60, 0.4),
        0 0 40px rgba(200, 40, 30, 0.3),
        inset 0 0 20px rgba(255, 140, 120, 0.12);
      opacity: 0;
      z-index: 2;
      overflow: hidden;
      pointer-events: none;
    }
    .forge-holo-anim::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg,
        transparent,
        rgba(224, 71, 60, 0.35),
        transparent
      );
      animation: holo-scan 3s linear infinite;
    }
    .forge-holo-anim::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        0deg,
        rgba(224, 71, 60, 0.12) 0px,
        transparent 2px,
        transparent 4px
      );
      animation: holo-lines 0.1s linear infinite;
    }
    .forge-holo-anim.animate {
      animation: forge-holo-expand 1.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      opacity: 1;
    }
    .forge-popup-overlay.ready .forge-holo-anim {
      opacity: 0;
      display: none;
    }
    @keyframes forge-holo-expand {
      0% {
        width: 60px;
        height: 80px;
        opacity: 0;
        border-color: rgba(255, 180, 0, 0);
        box-shadow: 0 0 0 rgba(255, 165, 0, 0);
      }
      20% {
        opacity: 1;
        border-color: rgba(224, 71, 60, 0.85);
        box-shadow:
          0 0 30px rgba(224, 71, 60, 0.6),
          0 0 60px rgba(200, 40, 30, 0.4),
          inset 0 0 30px rgba(255, 140, 120, 0.2);
      }
      100% {
        width: 80vw;
        height: 80vh;
        opacity: 0.85;
        border-color: rgba(224, 71, 60, 0.6);
      }
    }
    .forge-popup-close {
      position: absolute;
      top: 16px;
      right: 18px;
      width: 34px;
      height: 34px;
      border-radius: 50%;
      border: 1px solid rgba(224, 71, 60, 0.6);
      background: rgba(12, 10, 10, 0.8);
      color: #ffb3ab;
      font-size: 18px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 0 12px rgba(224, 71, 60, 0.35);
      z-index: 3;
      pointer-events: auto;
    }
    .forge-popup-close:hover {
      background: rgba(224, 71, 60, 0.2);
      color: #fff;
    }
    @keyframes forge-cog-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Bottom controls */
    .bottom-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1100; /* UI controls on top */
      pointer-events: all;
    }
    
    .recent-crafts {
      background: linear-gradient(135deg, rgba(20, 15, 13, 0.95), rgba(15, 10, 8, 0.98));
      border: 1px solid rgba(224, 71, 60, 0.4);
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
    }
    
    .recent-title {
      font-size: 9px;
      font-weight: 700;
      color: #c9d0d8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }
    
    .craft-items {
      display: grid;
      grid-template-columns: repeat(16, 1fr);
      gap: 8px;
    }
    
    .craft-item {
      width: 55px;
      height: 55px;
      background: rgba(224, 71, 60, 0.1);
      border: 1px solid rgba(224, 71, 60, 0.3);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      background-size: cover;
      background-position: center;
      color: #7b8088;
      font-size: 10px;
    }
    
    .craft-item:hover {
      border-color: #e0473c;
      background: rgba(224, 71, 60, 0.2);
      transform: scale(1.05);
    }
    .forge-status {
      margin-top: 10px;
      font-size: 10px;
      color: #9aa3ad;
      min-height: 14px;
    }
    .forge-status.active { color: #ffb199; }
    .forge-status.success { color: #7ddc9b; }
    .forge-status.error { color: #ef5a5a; }
    /* --- Additional Forge Atmosphere and Effects (from uitesting) --- */
    #design-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 900; /* behind panels (1100) but in front of flames (800) */
      background-image: url('./frame/fg1.png');
      background-size: 100% 100%; background-position: center;
      opacity: 1.0; display: block;
    }

    #forge-atmosphere {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      z-index: 800; /* sequence position 4 (effects group) */
      overflow: hidden; pointer-events: none;
      background: linear-gradient(to top, rgba(0,0,0,0.6) 0%, transparent 100%);
    }

    .fire-container {
      position: absolute;
      bottom: 36px;
      width: 260px;
      height: 340px;
      z-index: 775; /* below other effects, above furnace */
      pointer-events: none;
      filter: blur(0.8px);
    }
    .fire-left { 
      left: 5%; 
      transform: rotateZ(10deg);
      transform-origin: center bottom;
    }
    .fire-right { 
      right: 5%; 
      transform: rotateZ(-10deg);
      transform-origin: center bottom;
    }

    .flame {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at 50% 100%,
          rgba(255, 220, 140, 0.95) 0%,
          rgba(255, 150, 70, 0.85) 25%,
          rgba(255, 90, 30, 0.55) 50%,
          rgba(160, 30, 10, 0.25) 70%,
          transparent 90%);
      animation: flicker-flame 0.35s infinite alternate;
      transform-origin: bottom center;
      opacity: 0.8;
      filter: blur(6px);
    }

    .flame-core {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 78%;
      height: 60%;
      background: radial-gradient(ellipse at 50% 100%,
          rgba(255, 255, 200, 1) 0%,
          rgba(255, 200, 100, 0.9) 10%,
          rgba(255, 150, 0, 0.6) 30%,
          transparent 50%);
      animation: core-pulse 0.6s infinite alternate;
      filter: blur(2px);
    }

    @keyframes flicker-flame { 0% { transform: scaleY(1) scaleX(1); } 50% { transform: scaleY(1.05) scaleX(0.95);} 100% { transform: scaleY(0.98) scaleX(1.02);} }
    @keyframes core-pulse { 0% { transform: translateX(-50%) scale(1); } 100% { transform: translateX(-50%) scale(1.18); } }

    .fire-particle { position: absolute; bottom: 0; width: 8px; height: 8px; background: radial-gradient(circle, rgba(255,150,0,1), transparent); border-radius:50%; animation: rise-particle 3.5s infinite; opacity:0; }
    @keyframes rise-particle { 0% { transform: translateY(0) translateX(0) scale(1); opacity:0;} 10% { opacity:1;} 50% { transform: translateY(-160px) translateX(var(--drift-x)) scale(0.8); opacity:0.8;} 100% { transform: translateY(-360px) translateX(calc(var(--drift-x) * 2)) scale(0.3); opacity:0;} }

    .heat-shimmer { position: absolute; bottom: 0; width: 100%; height: 420px; z-index: 800; pointer-events: none; background: linear-gradient(to top, rgba(255,100,0,0.035) 0%, transparent 60%); filter: blur(3px); animation: shimmer 2s infinite; }

    @keyframes shimmer { 0%,100% { transform: skewX(0) translateX(0); opacity:0.28 } 50% { transform: skewX(1deg) translateX(2px); opacity:0.38 } }

    /* Steam / fog puffs */
    .steam-particle { position: fixed; bottom: -100px; z-index: 900; pointer-events: none; background-image: url('./frame/steam.png'); background-size: contain; background-repeat: no-repeat; background-position: center; opacity: 0; transform-origin: center center; }
    .steam-left { animation: dragon-vent-left var(--steam-duration) cubic-bezier(0.2,0.8,0.6,1.0) forwards; }
    .steam-right { animation: dragon-vent-right var(--steam-duration) cubic-bezier(0.2,0.8,0.6,1.0) forwards; }
    @keyframes dragon-vent-left { 0% { opacity:0; transform: translate(0,0) scale(0.1) rotate(0deg);} 5% { opacity:0.8; transform: translate(calc(var(--dest-x) * 0.1), calc(var(--dest-y) * 0.1)) scale(0.5) rotate(5deg);} 70% { opacity:0.5;} 100% { opacity:0; transform: translate(var(--dest-x), var(--dest-y)) scale(4) rotate(var(--rotation)); } }
    @keyframes dragon-vent-right { 0% { opacity:0; transform: translate(0,0) scale(-0.1,0.1) rotate(0deg);} 5% { opacity:0.8; transform: translate(calc(var(--dest-x) * 0.1), calc(var(--dest-y) * 0.1)) scale(-0.5,0.5) rotate(-5deg);} 70% { opacity:0.5;} 100% { opacity:0; transform: translate(var(--dest-x), var(--dest-y)) scale(-4,4) rotate(var(--rotation)); } }

    /* Fire Glow Overlay - Anchored Steam Effect */
    .fire-glow-container {
      position: absolute;
      bottom: 36px;
      width: 260px;
      height: 340px;
      z-index: 776; /* just above fire */
      pointer-events: none;
    }

    .fire-glow {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('./frame/steam.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }

    .fire-glow.red {
      filter: sepia(100%) saturate(500%) brightness(1.2) hue-rotate(-50deg);
      animation: pulse-glow-red 1.5s infinite ease-in-out;
    }

    .fire-glow.orange {
      filter: sepia(100%) saturate(600%) brightness(1.4) hue-rotate(10deg);
      animation: pulse-glow-orange 2.2s infinite ease-in-out;
      animation-delay: 0.15s;
    }

    .fire-glow.orange-screen {
      filter: sepia(100%) saturate(600%) brightness(1.4) hue-rotate(10deg);
      animation: pulse-glow-orange-screen 1.8s infinite ease-in-out;
      animation-delay: 0.15s;
      mix-blend-mode: screen;
    }

    .fire-glow.yellow {
      filter: sepia(100%) saturate(800%) brightness(1.6) hue-rotate(30deg);
      animation: pulse-glow-yellow 2.5s infinite ease-in-out;
      animation-delay: 0.25s;
    }

    .fire-glow.white {
      filter: brightness(2.5) saturate(0);
      animation: pulse-glow-white 3s infinite ease-in-out;
      animation-delay: 0.1s;
      mix-blend-mode: screen;
    }

    @keyframes pulse-glow-red {
      0% { opacity: 0.25; transform: scale(1) rotate(0deg); }
      25% { opacity: 0.35; transform: scale(1.15) rotate(30deg); }
      50% { opacity: 0.25; transform: scale(1) rotate(-15deg); }
      75% { opacity: 0.35; transform: scale(1.15) rotate(30deg); }
      100% { opacity: 0.25; transform: scale(1) rotate(0deg); }
    }

    @keyframes pulse-glow-orange {
      0% { opacity: 0.25; transform: scale(0.7) rotate(0deg); }
      25% { opacity: 0.35; transform: scale(0.805) rotate(30deg); }
      50% { opacity: 0.25; transform: scale(0.7) rotate(-15deg); }
      75% { opacity: 0.35; transform: scale(0.805) rotate(30deg); }
      100% { opacity: 0.25; transform: scale(0.7) rotate(0deg); }
    }

    @keyframes pulse-glow-orange-screen {
      0% { opacity: 0.25; transform: scale(0.7) rotate(0deg); }
      25% { opacity: 0.35; transform: scale(0.805) rotate(30deg); }
      50% { opacity: 0.25; transform: scale(0.7) rotate(-15deg); }
      75% { opacity: 0.35; transform: scale(0.805) rotate(30deg); }
      100% { opacity: 0.25; transform: scale(0.7) rotate(0deg); }
    }

    @keyframes pulse-glow-yellow {
      0% { opacity: 0.1875; transform: scale(0.4165) rotate(0deg); }
      50% { opacity: 0.2625; transform: scale(0.5635) rotate(0deg); }
      100% { opacity: 0.1875; transform: scale(0.4165) rotate(0deg); }
    }

    @keyframes pulse-glow-white {
      0% { opacity: 0; transform: scale(0.15) translate(5px, 0); }
      25% { opacity: 0.6; transform: scale(0.15) translate(0, -5px); }
      50% { opacity: 0.3; transform: scale(0.15) translate(-5px, 0); }
      75% { opacity: 0.6; transform: scale(0.15) translate(0, 5px); }
      100% { opacity: 0; transform: scale(0.15) translate(5px, 0); }
    }
  </style>
</head>
<body>
  <svg class="svg-filters" aria-hidden="true" focusable="false">
    <filter id="forge-wavy" x="-40%" y="-40%" width="180%" height="180%" filterUnits="objectBoundingBox">
      <feTurbulence id="forge-wavy-turbulence" type="turbulence" baseFrequency="0.01 0.02" numOctaves="1" seed="4" result="noise" />
      <feDisplacementMap in="SourceGraphic" in2="noise" scale="50" xChannelSelector="R" yChannelSelector="G" result="displaced" />
      <feGaussianBlur in="SourceAlpha" stdDeviation="6" result="alphaBlur" />
      <feComposite in="displaced" in2="alphaBlur" operator="in" result="masked" />
      <feFlood flood-color="rgb(178, 28, 28)" flood-opacity="0.3" result="tint" />
      <feComposite in="tint" in2="masked" operator="in" result="tinted" />
      <feBlend in="masked" in2="tinted" mode="screen" />
      <animate xlink:href="#forge-wavy-turbulence" attributeName="baseFrequency" dur="60s" keyTimes="0;0.5;1"
        values="0.01 0.02;0.02 0.04;0.01 0.02" repeatCount="indefinite" />
    </filter>
  </svg>
  <div class="forge-popup-overlay" id="forgePopupOverlay" aria-hidden="true">
    <div class="forge-popup-shell" id="forgePopupShell">
      <div class="forge-popup-window"></div>
      <div class="forge-popup-content">
        <button class="forge-popup-close" id="forgePopupClose" aria-label="Cancel">Ã—</button>
        <div class="forge-popup-title" id="forgePopupTitle"></div>
        <div class="forge-popup-status" id="forgePopupStatus">
          <div class="forge-popup-cogs" id="forgePopupCogs">
            <div class="forge-cog cog-rev" id="forgeCogLeft"></div>
            <div class="forge-cog cog-mid" id="forgeCogCenter"></div>
            <div class="forge-cog" id="forgeCogRight"></div>
          </div>
          <div class="forge-popup-message" id="forgePopupMessage"></div>
        </div>
        <div class="forge-popup-results" id="forgePopupResults">
          <div class="forge-popup-thumb"><img id="forgeResult1" alt="Forge result 1"></div>
          <div class="forge-popup-thumb"><img id="forgeResult2" alt="Forge result 2"></div>
          <div class="forge-popup-thumb"><img id="forgeResult3" alt="Forge result 3"></div>
        </div>
      </div>
      <div class="forge-popup-holo"></div>
    </div>
    <div class="forge-holo-anim" id="forgeHoloAnim"></div>
  </div>
  <div class="page-background"></div>
  <header>
    <div class="nav">
      <div class="brand">
        <div class="brand-icon">N</div>
        <span>NEUROFOUNDRY</span>
      </div>
      <nav class="links">
        <a class="navlink" href="home.html">Home</a>
        <a class="navlink" href="forge_final.html">Forge</a>
        <div class="nav-item dropdown">
          <button class="dropdown-toggle" type="button">
            Archives <span class="dropdown-caret">v</span>
          </button>
          <div class="dropdown-menu">
            <a href="technology.html">Technology</a>
            <a href="downloads.html">Downloads</a>
            <a href="button2.html">Manifesto</a>
            <a href="neurofoundry-report.html">Report</a>
          </div>
        </div>
        <a class="navlink" href="about.html">About</a>
        <a class="btn primary" href="signup.html">Request Access</a>
      </nav>
    </div>
  </header>

  <div class="forge-container">
    <!-- Furnace background split into back (bg) and front (frame) -->
    <div class="furnace-back"></div>
    <div class="furnace-front"></div>
    <div class="furnace-overlay"></div>

    <!-- Design foreground overlay (decorative layering) -->
    <div id="design-overlay"></div>

    <!-- Full-scene atmosphere container (embers + steam spawn) -->
    <div id="forge-atmosphere"></div>

    <!-- Fire / Flames (left + right) -->
    <div class="fire-container fire-left" aria-hidden="true">
      <div class="flame" style="--flicker-speed:0.33s;"></div>
      <div class="flame" style="--flicker-speed:0.43s; opacity:0.85;"></div>
      <div class="flame-core" style="--pulse-speed:0.6s;"></div>
    </div>
    <div class="fire-glow-container fire-left" aria-hidden="true">
      <div class="fire-glow red"></div>
      <div class="fire-glow orange"></div>
      <div class="fire-glow orange-screen"></div>
      <div class="fire-glow yellow"></div>
      <div class="fire-glow white"></div>
    </div>
    <div class="fire-container fire-right" aria-hidden="true">
      <div class="flame" style="--flicker-speed:0.36s;"></div>
      <div class="flame" style="--flicker-speed:0.46s; opacity:0.85;"></div>
      <div class="flame-core" style="--pulse-speed:0.65s;"></div>
    </div>
    <div class="fire-glow-container fire-right" aria-hidden="true">
      <div class="fire-glow red"></div>
      <div class="fire-glow orange"></div>
      <div class="fire-glow orange-screen"></div>
      <div class="fire-glow yellow"></div>
      <div class="fire-glow white"></div>
    </div>

    <!-- Heat shimmer above the furnace mouth -->
    <div class="heat-shimmer" aria-hidden="true"></div>

    <!-- Floating embers (fallback static items; dynamic embers also spawn into #forge-atmosphere) -->
    <div class="ember-container">
      <div class="ember"></div>
      <div class="ember"></div>
      <div class="ember"></div>
      <div class="ember"></div>
      <div class="ember"></div>
      <div class="ember"></div>
      <div class="ember"></div>
      <div class="ember"></div>
    </div>
    
    <!-- Media Viewer (sits in furnace opening - between furnace and furnacebg) -->
    <div class="media-viewer">
      <div class="media-container">
        <div class="media-content" id="mediaContent">
          <div class="media-placeholder"></div>
        </div>
      </div>
    </div>
    
    <!-- Main workspace -->
    <div class="workspace">
      <!-- Panels overlay -->
      <div class="panels-container">
        <!-- Header with labels -->
        <div class="furnace-header">
          <div class="header-label">The Forge - V.2</div>
          
        </div>
        
        <!-- Side panels -->
        <div class="panels-row">
          <!-- Left panels -->
          <div class="left-panels">
            <!-- Origin Panel -->
            <div class="panel">
              <div class="panel-header">
                <div class="step-number">1</div>
                <div class="panel-title">Origin</div>
              </div>
              <p class="panel-description">Upload an Image for analysis</p>
              <div class="upload-zone">
                <div class="upload-icon">+</div>
                <input type="file" id="originUpload" style="display: none;" accept="image/*">
              </div>
            </div>

            <!-- Fusion Panel -->
            <div class="panel">
            <div class="panel-header">
              <div class="step-number">2</div>
              <div class="panel-title">Fusion</div>
            </div>
            <button type="button" class="fusion-clear" id="fusionClear" aria-label="Clear fusion">Ã—</button>
            <p class="panel-description">Or fuse them together.</p>
              
              <div class="fusion-grid" id="fusionGrid">
                <div class="fusion-item" data-role="subject" id="fusionSubject" role="button" tabindex="0">
                  <div class="fusion-label">Subject</div>
                  <div class="fusion-hint">Drop or click</div>
                  <input type="file" id="fusionSubjectInput" accept="image/*">
                  <span class="fusion-check"></span>
                </div>
                <div class="fusion-item" data-role="scene" id="fusionScene" role="button" tabindex="0">
                  <div class="fusion-label">Scene</div>
                  <div class="fusion-hint">Drop or click</div>
                  <input type="file" id="fusionSceneInput" accept="image/*">
                  <span class="fusion-check"></span>
                </div>
                <div class="fusion-item is-locked" data-role="style" id="fusionStyle" role="button" tabindex="0" aria-disabled="true">
                  <div class="fusion-label">Style</div>
                  <div class="fusion-hint">Optional</div>
                  <input type="file" id="fusionStyleInput" accept="image/*">
                  <span class="fusion-check"></span>
                </div>
              </div>
              <div class="fusion-status" id="fusionStatus">Waiting for subject + scene.</div>
              <div class="fusion-progress" aria-hidden="true">
                <span class="fusion-progress-fill" id="fusionProgressFill"></span>
              </div>
              <input type="hidden" id="fusionSubjectOutputImage">
              <input type="hidden" id="fusionSubjectOutputText">
              <input type="hidden" id="fusionSceneOutputText">
              <div class="panel-actions">
                <button class="furnace-toggle-btn" id="furnace-toggle">Toggle Frame</button>
                <button class="furnace-toggle-btn" id="sound-toggle" disabled>Toggle Sound</button>
              </div>
            </div>
          </div>

          <!-- Right Panel: Assemble -->
          <div class="right-panel-stack">
            <div class="panel right-panel">
              <div class="panel-header">
                <div class="step-number">3</div>
              <div class="panel-title">Synthesize</div>
              </div>
              <p class="panel-description">Define the vision. Style, context, and motion - woven into one.</p>
              
              <div class="input-group">
                <label class="input-label">Style <span class="field-check" id="styleCheck"></span></label>
                <select class="input-select" id="styleSelect" disabled>
                  <option>Cinematic</option>
                  <option>Documentary</option>
                  <option>Artistic</option>
                  <option>Dramatic</option>
                </select>
              </div>
              
              <div class="input-group">
                <label class="input-label">Positive Prompt <span class="field-check" id="positiveCheck"></span></label>
                <textarea class="input-field" id="positivePrompt" placeholder="Describe the subject..."></textarea>
              </div>
              
              <div class="input-group">
                <label class="input-label">Scene Prompt <span class="field-check" id="sceneCheck"></span></label>
                <textarea class="input-field" id="scenePrompt" placeholder="Describe the scene..."></textarea>
              </div>
              
              <div class="input-group">
                <label class="input-label">Negative Prompt</label>
                <textarea class="input-field" id="negativePrompt" placeholder="Avoid, exclude, or downplay..."></textarea>
              </div>
              
              <button class="ai-generate-btn">Resynthesize</button>
              <div class="synth-loading" id="synthLoading" aria-hidden="true">
                <div class="synth-loading-card">
                  <div class="synth-loading-text" id="synthLoadingText">Loading..</div>
                  <div class="synth-loading-bar"><span class="synth-loading-fill"></span></div>
                </div>
              </div>
            </div>
            <div class="render-btn is-disabled" role="button" tabindex="0" aria-label="Forge It" aria-disabled="true">
              <img src="../../renderanvil.png" alt="Forge It">
            </div>
          </div>
        </div>
        
      </div>
      
      <!-- Bottom controls -->
      <div class="bottom-controls">
        <div class="recent-crafts">
          <div class="recent-title">Recent Crafts</div>
          <div class="craft-items">
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
            <div class="craft-item"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- Atmosphere: dynamic embers, steam/ smoke bursts, and fire particles ---
    (function(){
      const atmosphere = document.getElementById('forge-atmosphere');

      // Dynamic embers that float upward inside the atmosphere layer
      if (atmosphere) {
        const emberCount = 48;
        for (let i = 0; i < emberCount; i++) {
          const ember = document.createElement('div');
          ember.className = 'ember';
          ember.style.left = (Math.random() * 100) + '%';
          ember.style.top = (Math.random() * 50 + 30) + '%';
          ember.style.animationDuration = (4 + Math.random() * 5) + 's';
          ember.style.animationDelay = -(Math.random() * 8) + 's';
          ember.style.setProperty('--drift', (Math.random() * 80 - 40) + 'px');
          atmosphere.appendChild(ember);
        }
      }

      // Create steam / smoke puffs near the media viewer (left/right)
      function createSteamBurst(side) {
        const media = document.querySelector('.media-viewer');
        const rect = media ? media.getBoundingClientRect() : { left: window.innerWidth / 2, right: window.innerWidth / 2 };
        const spawnX = side === 'left' ? (rect.left + 30) : (rect.right - 30);
        const clusterSize = 6;
        const baseDuration = 3500;

        for (let i = 0; i < clusterSize; i++) {
          const steam = document.createElement('div');
          steam.classList.add('steam-particle', side === 'left' ? 'steam-left' : 'steam-right');
          steam.style.left = spawnX + 'px';
          const size = Math.random() * 140 + 80;
          steam.style.width = size + 'px';
          steam.style.height = size + 'px';
          const duration = baseDuration + (Math.random() * 1800);
          steam.style.setProperty('--steam-duration', duration + 'ms');
          const spread = (Math.random() * 400 - 200);
          const finalX = side === 'left' ? (-100 + spread) + 'px' : (100 + spread) + 'px';
          const finalY = (-100 - (Math.random() * 20)) + 'vh';
          steam.style.setProperty('--dest-x', finalX);
          steam.style.setProperty('--dest-y', finalY);
          const rot = (Math.random() * 90 - 45) + 'deg';
          steam.style.setProperty('--rotation', rot);
          document.body.appendChild(steam);
          setTimeout(() => { steam.remove(); }, duration);
        }
      }

      const allowedIntervals = [12000, 18000, 25000];
      function scheduleNextBurst(side) {
        const nextInterval = allowedIntervals[Math.floor(Math.random() * allowedIntervals.length)];
        setTimeout(() => { createSteamBurst(side); scheduleNextBurst(side); }, nextInterval);
      }
      setTimeout(() => { createSteamBurst('left'); scheduleNextBurst('left'); }, 2000);
      setTimeout(() => { createSteamBurst('right'); scheduleNextBurst('right'); }, 6000);

      // Fire particles rising from each fire container
      function createFireParticles(container) {
        if (!container) return;
        const particleCount = 16;
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.className = 'fire-particle';
          particle.style.setProperty('--particle-x', (Math.random() * 80 + 10) + '%');
          particle.style.setProperty('--drift-x', (Math.random() * 60 - 30) + 'px');
          particle.style.setProperty('--rise-duration', (Math.random() * 2 + 2) + 's');
          particle.style.setProperty('--particle-delay', -(Math.random() * 4) + 's');
          container.appendChild(particle);
        }
      }

      createFireParticles(document.querySelector('.fire-left'));
      createFireParticles(document.querySelector('.fire-right'));
    })();

      const IS_LOCAL = location.hostname === 'localhost'
        || location.hostname === '127.0.0.1'
        || location.protocol === 'file:';
      const REMBG_BASE = IS_LOCAL
        ? 'http://127.0.0.1:5001'
        : 'https://extract.theneurofoundry.com';
      const REMBG_API = `${REMBG_BASE}/extract`;
      const REMBG_HEALTH = `${REMBG_BASE}/health`;
      const CAPTION_API = 'https://nfcr-synthesize.onrender.com/features/4/caption';
      const RENDER_API = 'https://nfcr-synthesize.onrender.com/features/4/render';
      const FUSION_API = 'https://prmptrndr.csirico9.workers.dev/fusion';
      const SYNTH_API = 'https://synth.csirico9.workers.dev';
      const AUTH_KEY = 'Tr1bXimgEnV1-sdbAI25';

      const uploadZone = document.querySelector('.upload-zone');
      const originInput = document.getElementById('originUpload');
      const fusionGrid = document.getElementById('fusionGrid');
      const fusionStatus = document.getElementById('fusionStatus');
      const fusionSubjectInput = document.getElementById('fusionSubjectInput');
      const fusionSceneInput = document.getElementById('fusionSceneInput');
      const fusionStyleInput = document.getElementById('fusionStyleInput');
      const fusionSubject = document.getElementById('fusionSubject');
      const fusionScene = document.getElementById('fusionScene');
      const fusionStyle = document.getElementById('fusionStyle');
      const fusionClear = document.getElementById('fusionClear');
      const fusionProgressFill = document.getElementById('fusionProgressFill');
      const furnaceToggle = document.getElementById('furnace-toggle');
      const furnaceFront = document.querySelector('.furnace-front');
      const fusionSubjectOutputImage = document.getElementById('fusionSubjectOutputImage');
      const fusionSubjectOutputText = document.getElementById('fusionSubjectOutputText');
      const fusionSceneOutputText = document.getElementById('fusionSceneOutputText');
      const generateBtn = document.querySelector('.generate-btn');
      const renderBtn = document.querySelector('.render-btn');
      const mediaViewer = document.querySelector('.media-viewer');
      const mediaContent = document.getElementById('mediaContent');
      const statusEl = document.getElementById('forgeStatus');
      const recentContainer = document.querySelector('.craft-items');
      const styleSelect = document.getElementById('styleSelect');
      const styleCheck = document.getElementById('styleCheck');
      const positivePrompt = document.getElementById('positivePrompt');
      const positiveCheck = document.getElementById('positiveCheck');
      const scenePrompt = document.getElementById('scenePrompt');
      const sceneCheck = document.getElementById('sceneCheck');
      const negativePrompt = document.getElementById('negativePrompt');
      const resynthesizeBtn = document.querySelector('.ai-generate-btn');
      const synthLoading = document.getElementById('synthLoading');
      const forgePopupOverlay = document.getElementById('forgePopupOverlay');
      const forgePopupShell = document.getElementById('forgePopupShell');
      const forgeHoloAnim = document.getElementById('forgeHoloAnim');
      const forgePopupTitle = document.getElementById('forgePopupTitle');
      const forgePopupMessage = document.getElementById('forgePopupMessage');
      const forgePopupResults = document.getElementById('forgePopupResults');
      const forgeResult1 = document.getElementById('forgeResult1');
      const forgeResult2 = document.getElementById('forgeResult2');
      const forgeResult3 = document.getElementById('forgeResult3');
      const forgePopupClose = document.getElementById('forgePopupClose');

      const RECENT_KEY = 'forgeRecentRenders';
      const MAX_RECENT = 16;
      const AUTO_DOWNLOAD = true;
      const EXTRACT_TIMEOUT_MS = 45000;
      const FORGE_HOLO_ANIM_MS = 1400;
      const FORGE_MESSAGE_INTERVAL_MS = 2400;
      const RENDER_TIMEOUT_MS = 60000;
      const RENDER_MAX_ATTEMPTS = 3;
      const forgeMessages = [
        'Igniting the Forge...',
        'Initiating Thermal Transference...',
        'Accelerating Composite Fusion...',
        'Regulating Convergence...',
        'Analyzing the Artifacts...'
      ];
      let recentCache = [];

      let originImage = null;
      let subjectImage = null;
      let backgroundImage = null;
      let styleImage = null;
      let extractedSubject = null;
      let cdpContext = null;
      let acpContext = null;
      let sipContext = null;
      let mergedImage = null;
      let synthCaption = null;
      let isProcessing = false;
      let isExtracting = false;
      let isResynthesizing = false;
      let forgePopupTimer = null;
      let forgeMessageTimer = null;
      let forgeMessageIndex = 0;
      let forgeCancelled = false;

      function setStatus(message, level) {
        if (!statusEl) return;
        statusEl.textContent = message;
        statusEl.className = `forge-status ${level || ''}`.trim();
      }

      function setFusionStatus(message) {
        if (!fusionStatus) return;
        fusionStatus.textContent = message;
      }

      function setProcessing(state) {
        isProcessing = state;
        if (mediaViewer) {
          mediaViewer.classList.toggle('processing', state);
        }
        updateRenderState();
      }

      function setSynthesizeLoading(active) {
        if (!synthLoading) return;
        synthLoading.classList.toggle('active', active);
        synthLoading.setAttribute('aria-hidden', (!active).toString());
      }

      function maybeAutoFusion() {
        if (isProcessing) return;
        const ready = extractedSubject && cdpContext && backgroundImage && acpContext;
        if (!ready) return;
        runFusionPipeline();
      }

      function updateRenderState() {
        if (renderBtn) {
          const step3Ready = hasAllPromptChecks();
          const step1Or2Ready = hasOriginOrFusionReady();
          const ready = step1Or2Ready && step3Ready && !isProcessing;
          renderBtn.classList.toggle('ready', ready);
          renderBtn.classList.toggle('is-disabled', !ready);
          renderBtn.setAttribute('aria-disabled', (!ready).toString());
        }
        if (resynthesizeBtn) {
          const step3Ready = hasAllPromptChecks();
          const step2Ready = hasFusionChecks();
          resynthesizeBtn.disabled = isProcessing || !(step2Ready && step3Ready);
        }
        updateFusionChecklist();
      }

      function updateFusionClear() {
        if (!fusionClear) return;
        const hasFusionAssets = !!(subjectImage || backgroundImage || styleImage || extractedSubject || mergedImage);
        fusionClear.classList.toggle('visible', hasFusionAssets);
      }

      function updateFusionProgress() {
        if (!fusionProgressFill) return;
        const total = 3;
        const done =
          (fusionSubject && fusionSubject.classList.contains('has-image') ? 1 : 0) +
          (fusionScene && fusionScene.classList.contains('has-image') ? 1 : 0) +
          (fusionStyle && fusionStyle.classList.contains('has-image') ? 1 : 0);
        const percent = Math.round((done / total) * 100);
        fusionProgressFill.style.width = `${percent}%`;
      }

      function updateFusionChecklist() {
        updateFusionProgress();
        if (!generateBtn) return;
        const ready = hasFusionChecks();
        generateBtn.disabled = !ready || isProcessing || !!originImage;
      }

      function triggerForgePopup() {
        if (!forgePopupOverlay || !forgeHoloAnim) return;
        forgeCancelled = false;
        forgePopupOverlay.classList.add('active');
        forgePopupOverlay.classList.remove('ready');
        forgePopupOverlay.setAttribute('aria-hidden', 'false');
        if (forgePopupShell) {
          forgePopupShell.classList.remove('complete', 'results-started');
        }
        if (forgePopupTitle) {
          forgePopupTitle.textContent = '';
        }
        if (forgePopupMessage) {
          forgePopupMessage.textContent = '';
        }
        if (forgeResult1) forgeResult1.src = '';
        if (forgeResult2) forgeResult2.src = '';
        if (forgeResult3) forgeResult3.src = '';
        forgeHoloAnim.classList.remove('animate');
        void forgeHoloAnim.offsetWidth;
        forgeHoloAnim.classList.add('animate');
        if (forgePopupTimer) {
          clearTimeout(forgePopupTimer);
        }
        forgePopupTimer = setTimeout(() => {
          forgePopupOverlay.classList.add('ready');
          startForgeMessageLoop();
        }, FORGE_HOLO_ANIM_MS);
      }

      function startForgeMessageLoop() {
        if (!forgePopupMessage) return;
        if (!forgeMessages || forgeMessages.length === 0) {
          forgePopupMessage.textContent = '';
          return;
        }
        forgeMessageIndex = 0;
        forgePopupMessage.textContent = forgeMessages[forgeMessageIndex];
        if (forgeMessageTimer) {
          clearInterval(forgeMessageTimer);
        }
        forgeMessageTimer = setInterval(() => {
          forgeMessageIndex = (forgeMessageIndex + 1) % forgeMessages.length;
          forgePopupMessage.textContent = forgeMessages[forgeMessageIndex];
        }, FORGE_MESSAGE_INTERVAL_MS);
      }

      function stopForgeMessageLoop() {
        if (forgeMessageTimer) {
          clearInterval(forgeMessageTimer);
          forgeMessageTimer = null;
        }
      }

      function cancelForgePopup() {
        forgeCancelled = true;
        stopForgeMessageLoop();
        if (forgePopupOverlay) {
          forgePopupOverlay.classList.remove('active', 'ready');
          forgePopupOverlay.setAttribute('aria-hidden', 'true');
        }
        if (forgePopupShell) {
          forgePopupShell.classList.remove('complete', 'results-started');
        }
        if (forgeHoloAnim) {
          forgeHoloAnim.classList.remove('animate');
        }
        setProcessing(false);
        setStatus('Forge cancelled.', 'error');
      }

      function showForgeComplete(images) {
        if (!forgePopupShell || !forgePopupTitle) return;
        if (forgeCancelled) return;
        if (!images || images.length < 3) return;
        forgePopupShell.classList.add('complete');
        forgePopupTitle.textContent = 'Omnisynthesis: Complete';
        stopForgeMessageLoop();
        if (forgeResult1) forgeResult1.src = images[0] || '';
        if (forgeResult2) forgeResult2.src = images[1] || '';
        if (forgeResult3) forgeResult3.src = images[2] || '';
        renderRecent(recentCache);
      }

      function updateForgeResultSlot(slot, dataUrl) {
        if (!dataUrl) return;
        const targets = [forgeResult1, forgeResult2, forgeResult3];
        const target = targets[slot - 1];
        if (target) {
          target.src = dataUrl;
        }
        if (forgePopupShell) {
          forgePopupShell.classList.add('results-started');
        }
      }

      function displayImage(imageSrc, useDegen) {
        if (!mediaContent) return;
        if (mediaViewer) {
          mediaViewer.classList.toggle('degen-active', !!useDegen);
        }
        mediaContent.innerHTML = `<img src="${imageSrc}" alt="Render" />`;
      }

      function showPlaceholder() {
        if (!mediaContent) return;
        if (mediaViewer) {
          mediaViewer.classList.remove('degen-active');
        }
        mediaContent.innerHTML = `
          <div class="media-placeholder"></div>
        `;
      }

      function updateUploadZoneLabel(name, previewSrc) {
        if (!uploadZone) return;
        if (!previewSrc) {
          uploadZone.classList.remove('has-origin');
          uploadZone.innerHTML = `
            <div class="upload-icon">+</div>
            <div style="font-size: 9px; color: #9aa3ad; margin-top: 4px;">Drop image</div>
          `;
        } else {
          uploadZone.classList.add('has-origin');
          uploadZone.innerHTML = `
            <img class="origin-preview" src="${previewSrc}" alt="${name || 'Origin image'}">
            <button type="button" class="origin-clear" aria-label="Clear origin">x</button>
          `;
        }
        if (originInput && !uploadZone.contains(originInput)) {
          uploadZone.appendChild(originInput);
        }
      }

      function readFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(new Error('File read failed'));
          reader.readAsDataURL(file);
        });
      }

      async function fetchWithTimeout(url, options, timeoutMs) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
        try {
          return await fetch(url, { ...options, signal: controller.signal });
        } finally {
          clearTimeout(timeoutId);
        }
      }

      function setFusionPreview(el, dataUrl) {
        if (!el) return;
        el.classList.remove('has-image');
        el.style.backgroundImage = `url(${dataUrl})`;
        el.style.backgroundSize = 'cover';
        el.style.backgroundPosition = 'center';
      }

      function markFusionReady(el) {
        if (!el) return;
        el.classList.add('has-image');
      }

      function clearFusionImage(el) {
        if (!el) return;
        el.classList.remove('has-image');
        el.style.backgroundImage = '';
        el.style.backgroundSize = '';
        el.style.backgroundPosition = '';
      }

      function setHiddenValue(el, value) {
        if (!el) return;
        el.value = value || '';
      }

      function setFieldCheck(el, isReady) {
        if (!el) return;
        el.classList.toggle('active', !!isReady);
      }

      function updatePromptChecks() {
        if (isResynthesizing) {
          setFieldCheck(styleCheck, false);
          setFieldCheck(positiveCheck, false);
          setFieldCheck(sceneCheck, false);
          updateRenderState();
          return;
        }
        setFieldCheck(styleCheck, !!(styleSelect && styleSelect.value));
        setFieldCheck(positiveCheck, !!(positivePrompt && positivePrompt.value.trim()));
        setFieldCheck(sceneCheck, !!(scenePrompt && scenePrompt.value.trim()));
        updateRenderState();
      }

      function hasAllPromptChecks() {
        return !!(
          styleCheck &&
          positiveCheck &&
          sceneCheck &&
          styleCheck.classList.contains('active') &&
          positiveCheck.classList.contains('active') &&
          sceneCheck.classList.contains('active')
        );
      }

      function hasFusionChecks() {
        return !!(
          fusionSubject &&
          fusionScene &&
          fusionStyle &&
          fusionSubject.classList.contains('has-image') &&
          fusionScene.classList.contains('has-image') &&
          fusionStyle.classList.contains('has-image')
        );
      }

      function hasOriginOrFusionReady() {
        return !!(originImage || hasFusionChecks());
      }

      function stashSubjectOutput() {
        setHiddenValue(fusionSubjectOutputImage, extractedSubject);
        setHiddenValue(fusionSubjectOutputText, cdpContext);
      }

      function stashSceneOutput() {
        setHiddenValue(fusionSceneOutputText, acpContext);
      }

      function resetFusionState() {
        const prevSip = sipContext;
        subjectImage = null;
        backgroundImage = null;
        styleImage = null;
        extractedSubject = null;
        cdpContext = null;
        acpContext = null;
        sipContext = null;
        mergedImage = null;
        if (positivePrompt && synthCaption && positivePrompt.value === synthCaption) {
          positivePrompt.value = '';
        }
        if (scenePrompt && prevSip && scenePrompt.value === prevSip) {
          scenePrompt.value = '';
        }
        synthCaption = null;
        clearFusionImage(fusionSubject);
        clearFusionImage(fusionScene);
        clearFusionImage(fusionStyle);
        setHiddenValue(fusionSubjectOutputImage, '');
        setHiddenValue(fusionSubjectOutputText, '');
        setHiddenValue(fusionSceneOutputText, '');
        if (fusionSubjectInput) fusionSubjectInput.value = '';
        if (fusionSceneInput) fusionSceneInput.value = '';
        if (fusionStyleInput) fusionStyleInput.value = '';
        setFusionStatus('Waiting for subject + scene.');
        updateRenderState();
        updatePromptChecks();
        updateFusionClear();
      }

      function enableFusion(enabled) {
        if (!fusionGrid) return;
        fusionGrid.classList.toggle('disabled', !enabled);
      }

      function clearOrigin() {
        originImage = null;
        updateUploadZoneLabel('');
        showPlaceholder();
      }

      function clearOriginAndReset() {
        clearOrigin();
        enableFusion(true);
        resetFusionState();
      }

      async function handleOriginFile(file) {
        if (!file) return;
        const dataUrl = await readFile(file);
        originImage = dataUrl;
        displayImage(dataUrl, false);
        updateUploadZoneLabel(file.name, dataUrl);
        enableFusion(false);
        resetFusionState();
        setFusionStatus('Fusion disabled. Origin image loaded.');
        setStatus('Origin loaded. Ready to forge.', 'success');
        updateRenderState();
      }

      async function handleFusionFile(role, file) {
        if (!file) return;
        const dataUrl = await readFile(file);
        if (originImage) {
          clearOrigin();
          enableFusion(true);
        }
        if (role === 'subject') {
          const prevSip = sipContext;
          extractedSubject = null;
          cdpContext = null;
          sipContext = null;
          mergedImage = null;
          styleImage = null;
          if (positivePrompt && synthCaption && positivePrompt.value === synthCaption) {
            positivePrompt.value = '';
          }
          if (scenePrompt && prevSip && scenePrompt.value === prevSip) {
            scenePrompt.value = '';
          }
          synthCaption = null;
          subjectImage = dataUrl;
          setFusionPreview(fusionSubject, dataUrl);
          updateFusionClear();
          clearFusionImage(fusionStyle);
          setHiddenValue(fusionSubjectOutputImage, '');
          setHiddenValue(fusionSubjectOutputText, '');
          updatePromptChecks();
          updateRenderState();
          await extractSubject();
          return;
        } else if (role === 'scene') {
          const prevSip = sipContext;
          backgroundImage = dataUrl;
          setFusionPreview(fusionScene, dataUrl);
          updateFusionClear();
          styleImage = null;
          clearFusionImage(fusionStyle);
          if (positivePrompt && synthCaption && positivePrompt.value === synthCaption) {
            positivePrompt.value = '';
          }
          if (scenePrompt && prevSip && scenePrompt.value === prevSip) {
            scenePrompt.value = '';
          }
          synthCaption = null;
          setHiddenValue(fusionSceneOutputText, '');
          updatePromptChecks();
          updateRenderState();
          await processScene();
          return;
        } else if (role === 'style') {
          styleImage = dataUrl;
          setFusionPreview(fusionStyle, dataUrl);
          updateFusionClear();
          return;
        }
        setFusionStatus('Waiting for subject + scene.');
      }

      if (uploadZone && originInput) {
        uploadZone.addEventListener('click', (e) => {
          const clearBtn = e.target.closest('.origin-clear');
          if (clearBtn) {
            e.preventDefault();
            e.stopPropagation();
            clearOriginAndReset();
            return;
          }
          originInput.click();
        });
        uploadZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          uploadZone.style.borderColor = '#e0473c';
          uploadZone.style.background = 'rgba(224, 71, 60, 0.15)';
        });
        uploadZone.addEventListener('dragleave', () => {
          uploadZone.style.borderColor = 'rgba(224, 71, 60, 0.4)';
          uploadZone.style.background = 'rgba(224, 71, 60, 0.05)';
        });
        uploadZone.addEventListener('drop', async (e) => {
          e.preventDefault();
          uploadZone.style.borderColor = 'rgba(224, 71, 60, 0.4)';
          uploadZone.style.background = 'rgba(224, 71, 60, 0.05)';
          await handleOriginFile(e.dataTransfer.files[0]);
        });
        originInput.addEventListener('change', async (e) => {
          await handleOriginFile(e.target.files[0]);
        });
      }

      function bindFusionInput(item, input, role) {
        if (!item || !input) return;
        if (item.classList.contains('is-locked')) return;
        item.addEventListener('click', () => {
          input.click();
        });
        item.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            input.click();
          }
        });
        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          item.style.borderColor = '#e0473c';
        });
        item.addEventListener('dragleave', () => {
          item.style.borderColor = 'rgba(224, 71, 60, 0.3)';
        });
        item.addEventListener('drop', async (e) => {
          e.preventDefault();
          item.style.borderColor = 'rgba(224, 71, 60, 0.3)';
          await handleFusionFile(role, e.dataTransfer.files[0]);
        });
        input.addEventListener('change', async (e) => {
          await handleFusionFile(role, e.target.files[0]);
        });
      }

      bindFusionInput(fusionSubject, fusionSubjectInput, 'subject');
      bindFusionInput(fusionScene, fusionSceneInput, 'scene');
      bindFusionInput(fusionStyle, fusionStyleInput, 'style');

      if (fusionClear) {
        fusionClear.addEventListener('click', (event) => {
          event.preventDefault();
          resetFusionState();
        });
      }

      if (furnaceToggle && furnaceFront) {
        furnaceToggle.addEventListener('click', () => {
          furnaceFront.classList.toggle('is-hidden');
        });
      }

      if (styleSelect) {
        updatePromptChecks();
        styleSelect.addEventListener('change', updatePromptChecks);
      }
      if (positivePrompt) {
        positivePrompt.addEventListener('input', updatePromptChecks);
      }
      if (scenePrompt) {
        scenePrompt.addEventListener('input', updatePromptChecks);
      }

      const SIP_INSTRUCTION = `TASK: Identify the visual style of this image.

Output two lines only:
Color palette: <short palette>
Style: <short style>
`;

      async function runCdp(imageData) {
        const response = await fetch(`${FUSION_API}/cdp`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'x-auth-key': AUTH_KEY },
          body: JSON.stringify({ image_base64: imageData })
        });
        if (!response.ok) throw new Error(`CDP failed: ${response.status}`);
        const data = await response.json();
        return data.cdp || data.caption || data.output || '';
      }

      async function runAcp(imageData) {
        const response = await fetch(`${FUSION_API}/acp`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'x-auth-key': AUTH_KEY },
          body: JSON.stringify({ image_base64: imageData })
        });
        if (!response.ok) throw new Error(`ACP failed: ${response.status}`);
        const data = await response.json();
        return data.acp || data.caption || data.output || '';
      }

      async function runSip(imageData) {
        const response = await fetch(`${FUSION_API}/sip`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'x-auth-key': AUTH_KEY },
          body: JSON.stringify({ image_base64: imageData, instruction: SIP_INSTRUCTION })
        });
        if (!response.ok) throw new Error(`SIP failed: ${response.status}`);
        const data = await response.json();
        return data.sip || data.caption || data.output || '';
      }

      async function runSynth(cdp, acp, sip) {
        if (!cdp || !acp || !sip) {
          throw new Error('Synth input missing one or more captions');
        }
        const combined = `${cdp} ${acp} ${sip}`;
        const compressionPrompt = `Compress the following into a single vivid image caption. Maximum 75 tokens. Output only the caption:

${combined}`;
        const response = await fetch(SYNTH_API, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'x-auth-key': AUTH_KEY },
          body: JSON.stringify({ prompt: compressionPrompt })
        });
        const bodyText = await response.text();
        if (!response.ok) throw new Error(`Synth failed ${response.status}`);
        let data;
        try {
          data = JSON.parse(bodyText);
        } catch (err) {
          throw new Error('Synth returned non-JSON');
        }
        const result = data.synth || data.output || data.result || data.caption || data.text || '';
        if (!result || !result.trim()) throw new Error('Synth returned empty output');
        return result.trim();
      }

      async function extractSubject() {
        if (isExtracting || !subjectImage) return;
        isExtracting = true;
        setFusionStatus('Extracting subject...');
        try {
          let response;
          try {
            response = await fetchWithTimeout(REMBG_API, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ image: subjectImage })
            }, EXTRACT_TIMEOUT_MS);
          } catch (err) {
            if (err && err.name === 'AbortError') {
              throw new Error('Extraction timed out');
            }
            throw err;
          }
          if (!response.ok) throw new Error(`Extraction failed: ${response.status}`);
          const data = await response.json();
          extractedSubject = data.image;
          try {
            cdpContext = await runCdp(extractedSubject);
          } catch (err) {
            console.error(err);
            cdpContext = '';
            setFusionStatus('CDP failed. Extraction ok.');
          }
          stashSubjectOutput();
          if (extractedSubject && cdpContext) {
            markFusionReady(fusionSubject);
          }
          setFusionStatus('Subject extracted.');
          updateRenderState();
          maybeAutoFusion();
        } finally {
          isExtracting = false;
        }
      }

      async function processScene() {
        if (!backgroundImage) return;
        setFusionStatus('Analyzing scene...');
        try {
          acpContext = await runAcp(backgroundImage);
          setFusionStatus('Scene analyzed.');
        } catch (err) {
          console.error(err);
          acpContext = '';
          setFusionStatus('Scene analysis failed.');
        }
        stashSceneOutput();
        if (acpContext) {
          markFusionReady(fusionScene);
        }
        updateRenderState();
        maybeAutoFusion();
      }

      async function mergeImages() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 576;
        const ctx = canvas.getContext('2d');
        const loadImg = (src) => new Promise((resolve) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.src = src;
        });
        const [bgImg, subImg] = await Promise.all([
          loadImg(backgroundImage),
          loadImg(extractedSubject)
        ]);
        ctx.drawImage(bgImg, 0, 0, 1024, 576);
        const scale = Math.min(1024 / subImg.width, 576 / subImg.height) * 0.8;
        const w = subImg.width * scale;
        const h = subImg.height * scale;
        const x = (1024 - w) / 2;
        const y = (576 - h) / 2;
        ctx.drawImage(subImg, x, y, w, h);
        mergedImage = canvas.toDataURL('image/png');
        return mergedImage;
      }

      async function runFusionPipeline() {
        if (isProcessing) return;
        if (!subjectImage || !backgroundImage) return;
        setProcessing(true);
        setSynthesizeLoading(true);
        try {
          if (!extractedSubject) {
            await extractSubject();
          }
          if (!acpContext) {
            try {
              acpContext = await runAcp(backgroundImage);
            } catch (err) {
              console.error(err);
              acpContext = '';
              setFusionStatus('ACP failed. Continuing...');
            }
            stashSceneOutput();
            if (acpContext) {
              markFusionReady(fusionScene);
            }
          }
          mergedImage = await mergeImages();
          displayImage(mergedImage, true);
          styleImage = mergedImage;
          setFusionPreview(fusionStyle, mergedImage);
          markFusionReady(fusionStyle);
          try {
            sipContext = await runSip(mergedImage);
          } catch (err) {
            console.error(err);
            sipContext = '';
            setFusionStatus('SIP failed. Continuing...');
          }
          if (scenePrompt && sipContext) {
            scenePrompt.value = sipContext;
          }
          updatePromptChecks();
          if (cdpContext && acpContext && sipContext) {
            try {
              synthCaption = await runSynth(cdpContext, acpContext, sipContext);
              if (positivePrompt && synthCaption) {
                positivePrompt.value = synthCaption;
              }
              updatePromptChecks();
            } catch (err) {
              console.error(err);
            }
          }
          setFusionStatus('Fusion ready.');
          setStatus('Fusion ready. Press Forge.', 'success');
        } catch (err) {
          console.error(err);
          setFusionStatus(`Fusion failed: ${err.message}`);
          setStatus(`Fusion failed: ${err.message}`, 'error');
        } finally {
          setProcessing(false);
          setSynthesizeLoading(false);
        }
      }

      function buildPrompt(basePrompt) {
        const parts = [];
        if (basePrompt) parts.push(basePrompt);
        if (styleSelect && styleSelect.value) parts.push(styleSelect.value);
        if (positivePrompt && positivePrompt.value.trim()) parts.push(positivePrompt.value.trim());
        if (scenePrompt && scenePrompt.value.trim()) parts.push(scenePrompt.value.trim());
        return parts.join(', ');
      }

      function getNegativePrompt() {
        if (!negativePrompt) return '';
        return negativePrompt.value.trim();
      }

      function getRecentRenders() {
        try {
          const raw = localStorage.getItem(RECENT_KEY);
          return raw ? JSON.parse(raw) : [];
        } catch {
          return [];
        }
      }

      function saveRender(dataUrl) {
        if (!recentCache.length) {
          recentCache = getRecentRenders();
        }
        recentCache.unshift(dataUrl);
        recentCache = recentCache.slice(0, MAX_RECENT);
        try {
          localStorage.setItem(RECENT_KEY, JSON.stringify(recentCache));
        } catch (err) {
          console.error('Recent save failed', err);
        }
        renderRecent(recentCache);
      }

      function downloadImage(dataUrl, filename) {
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
      }

      function renderRecent(rendersOverride) {
        if (!recentContainer) return;
        const items = recentContainer.querySelectorAll('.craft-item');
        const renders = rendersOverride || recentCache || getRecentRenders();
        items.forEach((item, idx) => {
          const render = renders[idx];
          if (render) {
            item.style.backgroundImage = `url(${render})`;
            item.dataset.src = render;
          } else {
            item.style.backgroundImage = '';
            item.dataset.src = '';
          }
        });
      }

      if (recentContainer) {
        recentContainer.addEventListener('click', (e) => {
          const target = e.target.closest('.craft-item');
          if (!target) return;
          const src = target.dataset.src;
          if (!src) return;
          displayImage(src, false);
        });
      }

      async function renderImages(promptText, negativeText) {
        const outputs = [];
        const renderCount = 3;
        for (let i = 1; i <= renderCount; i++) {
          if (forgeCancelled) break;
          let success = false;
          for (let attempt = 1; attempt <= RENDER_MAX_ATTEMPTS; attempt++) {
            if (forgeCancelled) break;
            setStatus(`Rendering ${i}/${renderCount}...`, 'active');
            try {
              const response = await fetchWithTimeout(RENDER_API, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  method: 'prompt',
                  prompt: promptText,
                  negative_prompt: negativeText,
                  model: '@cf/stabilityai/stable-diffusion-xl-base-1.0',
                  width: 1024,
                  height: 576,
                  guidance_scale: 7.5,
                  num_inference_steps: 25
                })
              }, RENDER_TIMEOUT_MS);
              if (!response.ok) {
                throw new Error(`Render ${i} failed: ${response.status}`);
              }
              const data = await response.json();
              if (data.ok && data.image_base64) {
                const dataUrl = `data:image/png;base64,${data.image_base64}`;
                outputs.push(dataUrl);
                updateForgeResultSlot(outputs.length, dataUrl);
                displayImage(dataUrl, false);
                saveRender(dataUrl);
                if (AUTO_DOWNLOAD) {
                  downloadImage(dataUrl, `forge_render_${Date.now()}_${i}.png`);
                }
                success = true;
                break;
              }
              throw new Error(`Render ${i} returned empty output`);
            } catch (err) {
              console.error(err);
              setStatus(`Render ${i} retry ${attempt}/${RENDER_MAX_ATTEMPTS}`, 'error');
            }
          }
          if (!success) {
            setStatus(`Render ${i} failed.`, 'error');
            break;
          }
        }
        if (!forgeCancelled && outputs.length === renderCount) {
          showForgeComplete(outputs);
        }
        return outputs;
      }

      if (renderBtn) {
        renderBtn.addEventListener('click', async () => {
          if (isProcessing || renderBtn.classList.contains('is-disabled')) return;
          const step3Ready = hasAllPromptChecks();
          const step1Or2Ready = hasOriginOrFusionReady();
          if (!step3Ready || !step1Or2Ready) return;
          triggerForgePopup();
          setProcessing(true);
          try {
            let basePrompt = '';
          if (!originImage) {
            if (!mergedImage || !cdpContext || !acpContext || !sipContext) {
              throw new Error('Fusion not ready. Add subject and scene first.');
            }
            if (!synthCaption) {
              synthCaption = await runSynth(cdpContext, acpContext, sipContext);
            }
            basePrompt = synthCaption || '';
            if (positivePrompt && basePrompt) {
              positivePrompt.value = basePrompt;
            }
            updatePromptChecks();
          }
            const promptText = buildPrompt(basePrompt);
            const negativeText = getNegativePrompt();
            await renderImages(promptText, negativeText);
            setStatus('Render complete.', 'success');
          } catch (err) {
            setStatus(`Render failed: ${err.message}`, 'error');
            cancelForgePopup();
          } finally {
            if (!forgeCancelled) {
              setProcessing(false);
            }
          }
        });
        renderBtn.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            renderBtn.click();
          }
        });
      }

      if (resynthesizeBtn) {
        resynthesizeBtn.addEventListener('click', async () => {
          if (isProcessing || resynthesizeBtn.disabled) return;
          const step3Ready = hasAllPromptChecks();
          const step2Ready = hasFusionChecks();
          if (!step3Ready || !step2Ready) return;
          if (!cdpContext || !acpContext || !sipContext) {
            setStatus('Fusion captions not ready. Upload subject + scene first.', 'error');
            return;
          }
          try {
            isResynthesizing = true;
            setSynthesizeLoading(true);
            updatePromptChecks();
            setStatus('Resynthesizing caption...', 'active');
            synthCaption = await runSynth(cdpContext, acpContext, sipContext);
            if (positivePrompt && synthCaption) {
              positivePrompt.value = synthCaption;
            }
            setStatus('Caption resynthesized.', 'success');
          } catch (err) {
            setStatus(`Resynthesize failed: ${err.message}`, 'error');
          } finally {
            isResynthesizing = false;
            setSynthesizeLoading(false);
            updatePromptChecks();
          }
        });
      }

      if (forgePopupClose) {
        forgePopupClose.addEventListener('click', cancelForgePopup);
      }

      if (generateBtn) {
        generateBtn.addEventListener('click', async () => {
          if (generateBtn.disabled) return;
          await runFusionPipeline();
        });
      }

      window.addEventListener('load', async () => {
        recentCache = getRecentRenders();
        renderRecent(recentCache);
        updateUploadZoneLabel('');
        updateRenderState();
        try {
          await fetch(REMBG_HEALTH);
          await fetch('https://nfcr-synthesize.onrender.com/features/4/images');
        } catch (error) {
          setStatus('Services not detected. Render may fail.', 'error');
        }
      });
</script>
  <script src="shared/page-transitions.js"></script>
  <script src="shared/micro-interactions.js"></script>
  <script src="chatbot-component.js"></script>
  <script src="embers-effect.js"></script>
</body>
</html>
